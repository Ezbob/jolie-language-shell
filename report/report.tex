\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage[a4paper,top=2.1cm,bottom=2.1cm,left=2.4cm,right=2.4cm]{geometry}

\title{ \textbf{DM848}: Microservice Programming \\ {\Large Sandboxed Interpreter for Interactive Code Execution Using Docker} }
\author{Anders Busch, anbus12@student.sdu.dk}
\date{\today \\ \hrulefill{}}

%New command for inserting images put the images in pics subfolder
%synopsis: \img{ scale }{ image name }{ caption text }
\newcommand{\img}[3] {
	\begin{center}
	\includegraphics[scale=#1]{pics/#2}\\
	{\small #3}
	\end{center}
}

%New command for inserting pdfs put the pdfs in pics subfolder
%synopsis: \pdf{ scale }{ page number }{ image name }{ caption text }
\newcommand{\pdf}[4] {
	\begin{center}
	\includegraphics[scale=#1,page=#2]{pics/#3}\\
	{\small #4}
	\end{center}
}

% code listing options, can be "overload" by cascading 
\lstset{breaklines=true, tabsize=4, numbers=left, title=\lstname, language=c}

\newcommand{\docker}[0] {\textsc{docker}}
\newcommand{\jolie}[0] {\textsc{jolie}}
\newcommand{\git} {\textsc{git}}
\newcommand{\ubuntu} {\textsc{ubuntu}}

\renewcommand{\baselinestretch}{1.5}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}

When learning a new programming language, it is often useful to have a environment where the learner can execute code, quick and easy without having to worry about breaking the execution environment or installing new software locally. \\

\noindent{}The goal of this project was to create a cloud server for executing \jolie{} programs through the browser; and to embed the cloud server in a virtual environment provided by the virtualization library \docker{}.\\

\noindent{}To achieve this goal, we had to solve the following problems:
\begin{enumerate}
	\item Create an \docker{} image for running \jolie{} code in a \docker{} container. This image helps automating the process of creating new containers and is available on-line\footnote{https://hub.docker.com/r/ezbob/jolie/} for everyone interested in using \docker{} in conjunction with \jolie{}.
	\item Produce a service for handling the setup of the \docker{} container. As our execution environment uses \jolie{} to communicate between services, we opted to create a service that handles the communication with the \docker{} CLI.
	\item Make a service that can evaluate \jolie{} within the \docker{} container. For our evaluator to work, we have decided to use a \jolie{} service to evaluate sent \jolie{} code.
	\item Assemble a front-end service for presenting and handling of the user interface. Here we opted for a simple \jolie{}-based HTTP server that serves our user interface. 
\end{enumerate}


\section{Preliminaries}

\subsection{Docker}

The \docker{} application is a lightweight virtualization technology that focuses on creating virtualization of applications in microservice manner.\cite{DBLP:journals/software/Anderson15}

\img{0.6}{arch}{\docker{} application architecture}

\paragraph{Architecture} \docker{} uses a server-client architecture to communicate between the client, and the underlying server, the \docker{} daemon. The client, in this case, is a front-end program that exposes some interface to the user (Command Line Interface or a RESTful API), and uses this to communicate with the daemon (the server). The server is the main workhorse program that builds, executes and maintains the different \docker{} containers.

\paragraph{Containers} A \docker{} container is the virtualization environment that contains a running application, and as such can be thought of an microservice or a instance of a class (using Object Oriented terminology) that the \docker{} daemon maintains. Container provides isolation for the running code and uses a layered file system called the union file system inside the container.\cite{DBLP:journals/software/Anderson15} This union file system keeps track of changes much in the same way version control systems, such as \git{}, does; namely by keeping track of writes and only write to the file system once an action has been committed. Containers are build from images.

\paragraph{Images} A \docker{} image, is an read-only minimal-size file that can be used to build new containers via the \docker{} daemon. These images make it possible to share different container-setup with different users, and can be created either using an existing \docker{} container or using a special file called a \docker{} file. 

\paragraph{Registries}
Images can either be fetched from a local repository called the \textbf{local registry} or remotely from a repository called the \textbf{remote registry}. \docker{} provides a standard remote registry service\footnote{https://hub.docker.com/} for fetching images such as an \ubuntu{} linux image and much more.

\paragraph{Volumes} A volume is a way of creating a persistent data volume within a container. A volume is created separately from any containers, initialized with any container and can be mounted to one or more containers for sharing of persistent data.

\paragraph{Docker Engine} The \docker{} engine is the part of the \docker{} daemon that handles the running containers. The engine communicates directly with the host operating system, on behave of the containers. This is different to most other virtual environments, where a hypervisor is employed support the virtual operating system running in the virtual environment.     

\section{Technical Description}



\section{Related Work and Discussion}

Although we partly achieved what we set out to create; there are some limitation in the current implementation that can be expanded upon in future revision of this execution tool, namely the support for inter-service communications, better error explanation and dynamic linting\footnote{https://en.wikipedia.org/wiki/Lint\_\%28software\%29} of the program code.

\bibliography{report} 
\bibliographystyle{ieeetr}


\end{document}
