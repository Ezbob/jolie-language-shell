\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage[a4paper,top=2.1cm,bottom=2.1cm,left=2.4cm,right=2.4cm]{geometry}

\title{ \textbf{DM848}: Microservice Programming \\ {\Large Sandboxed Interpreter for Interactive Code Execution Using Docker Virtualization} }
\author{Anders Busch, anbus12@student.sdu.dk}
\date{\today \\ \hrulefill{}}

%New command for inserting images put the images in pics subfolder
%synopsis: \img{ scale }{ image name }{ caption text }
\newcommand{\img}[3] {
	\begin{center}
	\includegraphics[scale=#1]{pics/#2}\\
	{\small #3}
	\end{center}
}

%New command for inserting pdfs put the pdfs in pics subfolder
%synopsis: \pdf{ scale }{ page number }{ image name }{ caption text }
\newcommand{\pdf}[4] {
	\begin{center}
	\includegraphics[scale=#1,page=#2]{pics/#3}\\
	{\small #4}
	\end{center}
}

% code listing options, can be "overload" by cascading 
\lstset{breaklines=true, tabsize=4, numbers=left, title=\lstname, language=c}

\newcommand{\docker}[0] {\textsc{docker}}
\newcommand{\jolie}[0] {\textsc{jolie}}
\newcommand{\git} {\textsc{git}}
\newcommand{\ubuntu} {\textsc{ubuntu}}
\newcommand{\java} {\textsc{java}}
\newcommand{\ace} {\textsc{ace}}

\renewcommand{\baselinestretch}{1.5}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}

When learning a new programming language, it is often useful to have a environment where the learner can execute code, quick and easy without having to worry about breaking the execution environment or installing new software locally.

\subsection{Application Goal}

The goal of this project was to create a cloud server for executing \jolie{} programs through the browser; and to embed the cloud server in a virtual environment provided by the virtualization library \docker{} to provide encapsulation and limit the resource consumption of the cloud server.

\subsection{Problems}

To achieve the application goal, we had to solve the following problems:
\begin{enumerate}
	\item Create an \docker{} image for running \jolie{} code in a \docker{} container. This image helps automating the process of creating new containers and is available on-line\footnote{https://hub.docker.com/r/ezbob/jolie/} for everyone interested in using \docker{} in conjunction with \jolie{}.
	\item Produce a service for handling the setup of the \docker{} container. As our execution environment uses \jolie{} to communicate between services, we opted to create a service that handles the communication with the \docker{} CLI.
	\item Make a service that can evaluate \jolie{} within the \docker{} container. For our evaluator to work, we have decided to use a \jolie{} service to evaluate sent \jolie{} code.
	\item Assemble a front-end service for presenting and handling of the user interface. Here we opted for a simple \jolie{}-based HTTP server that serves our user interface. 
\end{enumerate}

\section{Preliminaries}

\subsection{Docker Concepts}

The \docker{} application is a lightweight virtualization technology that focuses on creating virtualization of applications in microservice manner.\cite{DBLP:journals/software/Anderson15}

\img{0.6}{arch}{\docker{} application architecture}

\paragraph{Architecture} \docker{} uses a server-client architecture to communicate between the client, and the underlying server, the \docker{} daemon. The client, in this case, is a front-end program that exposes some interface to the user (Command Line Interface or a RESTful API), and uses this to communicate with the daemon (the server). The server is the main workhorse program that builds, executes and maintains the different \docker{} containers.

\paragraph{Containers} A \docker{} container is the virtualization environment that contains a running application, and as such can be thought of an microservice or a instance of a class (using Object Oriented terminology) that the \docker{} daemon maintains. Container provides isolation for the running code and uses a layered file system called the union file system inside the container.\cite{DBLP:journals/software/Anderson15} This union file system keeps track of changes much in the same way version control systems, such as \git{}, does; namely by keeping track of writes and only write to the file system once an action has been committed. Containers are build from images.\cite{DockerTutorial} 

\paragraph{Images} A \docker{} image, is an read-only minimal-size file that can be used to build new containers via the \docker{} daemon. These images make it possible to share different container-setup with different users, and can be created either using an existing \docker{} container or using a special file called a \docker{} file. 

\paragraph{Registries}
Images can either be fetched from a local repository called the \textbf{local registry} or remotely from a repository called the \textbf{remote registry}. \docker{} provides a standard remote registry service\footnote{https://hub.docker.com/} for fetching official images such as the \ubuntu{} linux image and user images such as \jolie{} image we have created to be used in this application.

\paragraph{Volumes} A volume is a way of creating a persistent data volume within a container. A volume is created separately from any containers, initialized with any container and can be mounted to one or more containers for sharing of persistent data.

\paragraph{Docker Engine} The \docker{} daemon together with the front-end service is called the \docker{} engine. The engine communicates directly with the host operating system, on behave of the containers. This is different to most other virtual environments, where a hypervisor is employed support the virtual operating system running in the virtual environment.\cite{DBLP:journals/software/Anderson15}

\paragraph{Encapsulation and Resource Configuration}
\docker{} uses two Linux kernel concepts to provide encapsulation and resource configuration for the containers; \textit{control groups} and \textit{namespaces}. 
\subparagraph{Control groups} or \textit{cgroups} enables the user to configure the resources of an container. This useful when one wants to limit for example the memory footprint or the number of CPU cores available for the container to use on the host machine.
\subparagraph{Namespaces} enables the encapsulation of a container as a process assigning some resources to it. Using namespaces limits the access from the container to the host system.  

\section{Technical Description}

\subsection{Application Overview}
Our application uses \jolie{} as the main choice of programming language, and is build around a number of microservices:

\begin{description}
\item[jolie\_docker] An embedded \java{} service that works as an interface for the \docker{} CLI. This service is responsible for creating containers and halting them through the \docker{} CLI. 
\item[docker\_jolie] This service is responsible for embedding the \textbf{jolie\_docker} service and act as an container server for \jolie{} clients. 
\item[eval\_frontend] A service that serves as the HTTP server front-end for the application. 
\item[server] A \jolie{} service, that serves as the cloud server embedded inside the \docker{} container.
\end{description}
The following diagram illustrates how the different services are connected:
\img{0.6}{system}{Overview of our application}
In the diagram, the dashed arrows indicates responses and the full arrows indicates request for some data.

\subsection{Configuration of the Docker Container}

When a service request a container, we pass some configuration parameters to \docker{} to limit the consumption of the host resources and to mount a certain portion of the host file system to hold the compiled \jolie{} file created within the container. The following configuration parameters are parsed during the initialization phase:
\begin{description}
\item[--read-only] makes the root file system read-only within the container.
\item[-m 256m] sets the main memory limit for the container to 256 mega bytes.
\item[--cpu-shares 256] sets a relative weighted upper bound on the how much the container can use the CPUs. The maximum number of shares is 1024.
\item[--cpuset-cpus 0,1] the container may only execute on CPU core 0 and 1.
\item[--expose $\langle$port$\rangle$] exposes a single port (selected by the client), to enable the communication with the contained service.
\end{description}
Furthermore, the \jolie{} image uses an user called "jolie" with no root privileges and uses the home directory "/home/jolie" as the main workspace for execution of \jolie{} programs.  

\subsection{Operations}
Our application supports three main operations:
\begin{enumerate}
\item Initialization and creation of a container using a configuration that limits the container resources.
\item User-inputted code that was submitted using the browser editor will be executed by the contained service.
\item Shutdown of the application and removal of the created containers.
\end{enumerate}

\subsubsection{Initialization}
The initialization process is depicted in the following diagram:
\img{0.7}{init}{The initialization process}
To start the initialization process the user has to start the \textbf{docker\_jolie} service first and then the \textbf{eval\_frontend} service. Once this is done, the initialization phase begins by creating a new container which contains the service \textbf{server}. A synchronization phase is used between \textbf{jolie\_docker} and \textbf{docker CLI}. This is done via examining the \docker{} logs for a pre-determined signal, emitted by \textbf{server}, to ensure that the contained service is up before proceeding.

\subsubsection{Code submission}
\noindent{}The submission process is depicted in the following diagram:
\img{0.7}{submit}{The code submission phase}
For completeness this diagram includes the request for a HTML page containing the code editor (created using the \ace{} library\footnote{https://ace.c9.io/\#nav=about}) and a submission request button.\\  

The code submission process is a relative simple one. The front-end talks serves HTML pages and handles communication directly with the contained cloud server. Messages between the browser and the front-end \textbf{eval\_frontend} are send via the HTTP standard unlike the other services in this application that uses the more compact protocol SODEP which has less overhead than HTTP. This reason here is, of course, that this is a protocol that the browser understands.

\subsubsection{Termination}
The following sequence diagram depicts the termination process:
\img{0.6}{term}{The termination process}
Each of our services includes a shutdown operation. As the \textbf{jolie\_docker} service is an embedded \java{} service it is also terminated automatically when the embedder service \textbf{docker\_jolie} is terminated. \\

\noindent{}The whole termination process stops all services and the containers associated with them. In a more realistic environment the option to shutdown all services and the containers would be left to the site administrator, but, for convenience sake, a server shutdown button is included in the user interface to initiate this process.\\

\noindent{}The \docker{} 'stop' and 'rm' commands are responsible for halting the container (and thus stopping the \textbf{server} service), and removing the remains of the container, respectively.

\subsection{User manual}
The installation steps and how-to guide are include in a read-me file called \textit{README} in code directory of this project.

\section{Related Work and Discussion}

Although we partly achieved what we set out to create; there are some limitation in the current implementation that can be expanded upon in future revision of this execution tool, namely the support for inter-service communications in the context of the code executioner (emulation of multiple services), better error explanation and dynamic linting\footnote{https://en.wikipedia.org/wiki/Lint\_\%28software\%29} of the program code.\\

\noindent{}We would also have liked to generalize the \textbf{docker\_jolie} service in such a way that it could handle the communication between the container and the \jolie{} client in a way that would allow for remote access to the container.

\newpage
\bibliography{report} 
\bibliographystyle{plain}


\end{document}
